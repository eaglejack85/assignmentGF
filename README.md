# assignmentGF - root module
Assignment for sessionM

## Description

I have been not able to test the ASG because of free subscription of my account
```
Error: Error creating Auto Scaling Group: ValidationError: You must use a valid fully-formed launch template. In order to use this AWS Marketplace product you need to accept terms and subscribe. To do so please visit https://aws.amazon.com/marketplace/pp?sku=1ezp0309fpbba37jhjay0jqq5
	status code: 400, request id: 8533b772-c922-4b54-be82-60055c8ca325
```
## Infrastructure deployment
For deployment of the infrastructure, requirement is to provide the set of mandatory variables (which in my local machine I set in variables.auto.tfvars) and the aws account credentials (in my local I added them in a user.auto.tfvars file).

List of mandatory variables (and example of assigned values I tried for testing the resources creation)
region              = "us-east-2"
vpc_cidr            = "10.0.0.0/16"
environment         = "myEnvGF"
public_subnet_cidr  = "10.0.2.0/24"
public_subnet_cidr2 = "10.0.3.0/24"
private_subnet_cidr = "10.0.1.0/24"
instance_shape      = "t2.micro"
ami_name            = "ubuntu-20.04*"
ami_owners          = ["679593333241"]
user_name           = "ubuntu"

The AWS account credentials are also mandatory variables:
access_key = "xxx"
secret_key = "***"

1. `terraform init`
2. `terraform apply`

Running `terraform apply` from the root folder will output the terraform plan and can be applied by typing `yes`.
Private and public ssh keys to access the ASG instances will be generated by terraform apply in the `generated` folder

## Files

### main.tf

setup of terraform state as local file named `'terraform.tfstate'`

call to submodules `instances` and `network`

### outputs.tf

- `vpc_id`: the vpc id
- `public_subnet_id, public_subnet_id2`: the (loadbalancer) public subnets ids
- `private_subnet_id`: the (autoscaling group instances) private subnet id
- `autoscaling_group_id`: the autoscaling group id
- `lb_id`: the autoscaling group load balancer id
- `lb_hostname`: the autoscaling group load balancer hostname

### providers.tf

setup of `aws` provider

### variables.auto.tfvars (not pushed to git)

- region: the region
- vpc_cidr: the cidr block for the vpc
- environment: the environment name used in resources tags
- public_subnet_cidr: the cidr block of the public subnet
- private_subnet_cidr: the cidr block of the private subnet
- instance_shape: the autoscaling group instances shape
- ami_name: the autoscaling group instances AMI name (can be a regular expression)
- ami_owners: the autoscling group instances AMI owner
- user_name: the default user of the AMI

### variables.tf

no default values defined for variables, causing variables.auto.tfvars or any other tfvars or command line variable mandatory

# Requirements

## VPC allowing future growth/scale

By setting the network prefix of the cidr block in variables.auto.tfvars (`vpc_cidr`), it allows creation of multiple subnets

## It must include both a public and private subnet - where the private subnet is used for compute and the public is used for the load balancers

The public subnet is associated with a route table that has a route to an Internet gateway.
The Internet gateway connects the VPC to the Internet and to other AWS services.
The private subnet is associated with a route table that has a route to a NAT gateway.
A NAT gateway has its own Elastic IPv4 address. Instances in the private subnet can send requests to the Internet through the NAT gateway over IPv4 (for example, for software updates).
By setting `vpc_zone_identifier = [var.private_subnet_id]` in the autoscaling group, the compute instances are created in the private subnet
By setting `subnets = [var.public_subnet_id,public_subnet_id2]` in the public application load balancer, the load balancer is allocated in the public subnets

## Assuming that end-users only contact the load balancers and the underlying instances are accessed for management purposes, design a security group scheme which supports the minimal set of ports required for communication

The security group rules associated with the security group in network module:
- Allow http and https connection to the load balancer.
- Allow ssh access to the autoscaling group instances.
- Allow all outbound traffic from both load balancer and autoscaling group instances.

## The AWS generated load balancer hostname will be used for requests to the public facing web application

Not sure of this requirement. Added load balancer hostname in the root module outputs as `lb_hostname`

## An autoscaling group should be created which utilizes the latest AWS AMI

This is part of `aws_launch_template.my_webserver_launch_template` where the AMI image id is returned by the data source `aws_ami.latest_ami` based on the variables `ami_name` and `ami_owners`

## The instances in the ASG must contain both a root volume to store the application/services

`block_device_mappings` for `device_name = "/dev/sda1"`is defined in the `aws_launch_template` bound to the autoscaling group.

## The instances in the ASG must contain a secondary volume meant to store any log data bound for /var/log

`block_device_mappings` for `device_name = "/dev/sdv1"`is defined in the `aws_launch_template` bound to the autoscaling group.

## The instances in the ASG must include a web server of your choice

`httpd` server is installed on the instances via the cloud init script in the `packages` section

## All requirements in this task for configuring the operating system should be defined in the launch configuration and/or the user data script

cloud init script is attached to the `aws_launch_template` assigned to the autoscaling group 

## Your module should not be tightly coupled to your AWS account 

`providers.tf` defines the aws provider and both `access_key` and `secret_key` are passed as variables.
In my local solution I used a `user.auto.tfvars` file with the following content:
```
access_key = "***"
secret_key = "***"
```
Both variables can be either defined in any *.tfvars file or any variable or variable file passed from command line with either `-var=` or `-var-file=`

## You must ensure that all data is encrypted at rest

## Ideally, you should design these web servers so they can be managed without logging in with the root key

private and public keys are generated by terraform provider tls_private_key in module `instances` and the public key is attached to the webservers via `aws_key_pair` resource bound to the autoscaling group.
adding the default AMI user to sudoers list in cloud init script, gives the possibility to ssh as the default user with the ssh keys and sudo

## We should have some sort of alarm mechanism that indicates when the application is experiencing any issues

## Configure the autoscaling group to automatically add and remove nodes based on load

It could be achieved by setting `initial_lifecycle_hook` attribute in the ASG or creating a `aws_autoscaling_lifecycle_hook` resource. Did not have time for research on this.

## You should assume that this web server may receive high volumes of web traffic, thus you should appropriately manage the storage/growth of logs

log rotation enabled in cloud init script for /etc/logrotate.d/httpd

## .gitignore

The following files and folders are excluded from git commit
```
*.tfvars
generated
.terraform
terraform.tfstate*
```